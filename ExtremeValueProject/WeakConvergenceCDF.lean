/-
Copyright (c) 2025 Kalle Kyt√∂l√§. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kalle Kyt√∂l√§, ...
-/
import ExtremeValueProject.CumulativeDistributionFunction
import ExtremeValueProject.AffineTransformation
import Mathlib

section weak_convergence_cdf

open Filter Topology NNReal ENNReal Set

/-- Lemma 4.3 (cdf-tight) in blueprint. -/
lemma CumulativeDistributionFunction.forall_pos_exists_lt_gt_continuousAt
    (F : CumulativeDistributionFunction) {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ) :
    ‚àÉ (a b : ‚Ñù), a < b ‚àß F a < Œµ ‚àß 1 - Œµ < F b ‚àß ContinuousAt F a ‚àß ContinuousAt F b := by
  sorry -- **Issue #16**

/-- Lemma 4.4 (subdivision-dense) in blueprint:
An interval `[a,b]` can be subdivided with points from a dense set so that the consecutive
differences are smaller than a given `Œ¥ > 0`. -/
lemma forall_exists_subdivision_diff_lt_of_dense {D : Set ‚Ñù} (D_dense : Dense D)
    {a b : ‚Ñù} (ha : a ‚àà D) (hb : b ‚àà D) (a_lt_b : a < b) {Œ¥ : ‚Ñù} (Œ¥_pos : 0 < Œ¥) :
    ‚àÉ (k : ‚Ñï) (cs : Fin (k + 1) ‚Üí ‚Ñù),
      (cs 0 = a) ‚àß (cs (Fin.last _) = b) ‚àß (Monotone cs) ‚àß (‚àÄ k, cs k ‚àà D) ‚àß
      (‚àÄ (j : Fin k), cs j.succ - cs j < Œ¥) := by
  sorry -- **Issue #22**

/-- Lemma 4.5 (continuous-function-approximation-subdivision) in blueprint:
An interval `[a,b]` can be subdivided with points from a dense set so that for a given
continuous function `f` the function values on the parts of the subdivision are smaller than
a given `Œµ > 0`. -/
lemma forall_exists_subdivision_dist_apply_lt_of_dense_of_continuous {D : Set ‚Ñù} (D_dense : Dense D)
    {f : ‚Ñù ‚Üí ‚Ñù} (f_cont : Continuous f) {a b : ‚Ñù} (ha : a ‚àà D) (hb : b ‚àà D) (a_lt_b : a < b)
    {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ) :
    ‚àÉ (k : ‚Ñï) (cs : Fin (k + 1) ‚Üí ‚Ñù),
      (cs 0 = a) ‚àß (cs (Fin.last _) = b) ‚àß (Monotone cs) ‚àß (‚àÄ k, cs k ‚àà D) ‚àß
      (‚àÄ (j : Fin k), ‚àÄ x ‚àà Icc (cs j) (cs j.succ), ‚àÄ y ‚àà Icc (cs j) (cs j.succ),
        dist (f x) (f y) < Œµ) := by
  let I : Set ‚Ñù := Icc a b
  have hI_compact : IsCompact I := isCompact_Icc
  have hI_nonempty : I.Nonempty := nonempty_Icc.mpr (le_of_lt a_lt_b)
  have hf_cont_I : ContinuousOn f I := f_cont.continuousOn
  have hf_unif_cont : UniformContinuousOn f I :=
    hI_compact.uniformContinuousOn_of_continuous hf_cont_I
  have h_Œ¥ : ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà I, ‚àÄ y ‚àà I, dist x y < Œ¥ ‚Üí dist (f x) (f y) < Œµ := by
    rw [Metric.uniformContinuousOn_iff] at hf_unif_cont
    exact hf_unif_cont Œµ Œµ_pos
  obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© := h_Œ¥
  obtain ‚ü®k, cs, h_cs_0, h_cs_last, h_cs_mono, h_cs_D, h_cs_diff‚ü© :=
    forall_exists_subdivision_diff_lt_of_dense D_dense ha hb a_lt_b hŒ¥_pos
  have h_cs_bound : ‚àÄ i : Fin k, ‚àÄ x ‚àà Icc (cs i) (cs i.succ), ‚àÄ y ‚àà Icc (cs i) (cs i.succ), dist (f x) (f y) < Œµ := by
    intro i x hx y hy
    have hx_I : x ‚àà I := by
      have h_lower : a ‚â§ cs i := by simpa [‚Üê h_cs_0] using h_cs_mono (Fin.zero_le _)
      have h_upper : cs i.succ ‚â§ b := by simpa [‚Üê h_cs_last] using h_cs_mono (Fin.le_last i.succ)
      exact Icc_subset_Icc h_lower h_upper hx
    have hy_I : y ‚àà I := by
      have h_lower : a ‚â§ cs i := by simpa [‚Üê h_cs_0] using h_cs_mono (Fin.zero_le _)
      have h_upper : cs i.succ ‚â§ b := by simpa [‚Üê h_cs_last] using h_cs_mono (Fin.le_last i.succ)
      exact Icc_subset_Icc h_lower h_upper hy
    have h_dist_xy : dist x y < Œ¥ := by
      have h_bound : dist x y ‚â§ cs i.succ - cs i := by exact Real.dist_le_of_mem_Icc hx hy
      exact lt_of_le_of_lt h_bound (h_cs_diff i)
    exact hŒ¥ x hx_I y hy_I h_dist_xy
  exact ‚ü®k, cs, h_cs_0, h_cs_last, h_cs_mono, h_cs_D, h_cs_bound‚ü©

/-- Preliminary to Lemma 4.6 (simple-integral-cdf-difference) in blueprint. -/
lemma CumulativeDistributionFunction.integral_indicator_eq (F : CumulativeDistributionFunction)
    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
    {a b : ‚Ñù} (a_le_b : a ‚â§ b) (Œ± : E) :
    ‚à´ x, (indicator (Ioc a b) (fun _ ‚Ü¶ Œ±)) x ‚àÇ F.measure =
      (F b - F a) ‚Ä¢ Œ± := by
  have h_meas : MeasurableSet (Ioc a b) := measurableSet_Ioc
  rw [MeasureTheory.integral_indicator h_meas, MeasureTheory.integral_const]
  have h_cdf : F.measure (Ioc a b) = ENNReal.ofReal (F b - F a) :=
    F.toStieltjesFunction.measure_Ioc a b
  congr
  simp [h_cdf, ENNReal.toReal_ofReal (sub_nonneg.mpr (F.mono a_le_b))]

/-- Lemma 4.6 (simple-integral-cdf-difference) in blueprint. -/
lemma CumulativeDistributionFunction.integral_sum_indicator_eq (F : CumulativeDistributionFunction)
    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
    {Œ∫ : Type*} {s : Finset Œ∫} (as : Œ∫ ‚Üí ‚Ñù) (bs : Œ∫ ‚Üí ‚Ñù) (h : ‚àÄ j, as j ‚â§ bs j) (Œ± : Œ∫ ‚Üí E) :
    ‚à´ x, ((‚àë j ‚àà s, indicator (Ioc (as j) (bs j)) (fun _ ‚Ü¶ Œ± j)) x) ‚àÇ F.measure =
      ‚àë j in s, (F (bs j) - F (as j)) ‚Ä¢ Œ± j := by
  -- It may be worthwhile to think about an improved phrasing of this.
  -- The previous lemma `CumulativeDistributionFunction.integral_indicator_eq` should be
  -- the key anyway.
  have h_int_sum_change : ‚à´ (x : ‚Ñù), (‚àë j ‚àà s, (Ioc (as j) (bs j)).indicator (fun x => Œ± j)) x ‚àÇF.measure  = ‚àë j ‚àà s, ‚à´ (x : ‚Ñù), (Ioc (as j) (bs j)).indicator (fun x => Œ± j) x ‚àÇF.measure  := by
    rw [‚Üê MeasureTheory.integral_finset_sum]
    simp_all only [measurableSet_Ioc, implies_true, Finset.sum_apply, MeasureTheory.integral_indicator_const]
    intro j _
    exact (MeasureTheory.integrable_const (Œ± j)).indicator measurableSet_Ioc
  rw [h_int_sum_change]
  congr
  ext j
  exact F.integral_indicator_eq (h j) _

open MeasureTheory Topology

/-- Theorem 4.8 (convergence-in-distribution-with-cdf) in blueprint:
Convergence of a sequence of c.d.f.s pointwise at all continuity points of the limit c.d.f. imply
convergence in distribution of the corresponding Borel probability measures on `‚Ñù`. -/
theorem tendsto_of_forall_continuousAt_tendsto_cdf
    (Œºs : ‚Ñï ‚Üí ProbabilityMeasure ‚Ñù) (Œº : ProbabilityMeasure ‚Ñù)
    (h : ‚àÄ x, ContinuousAt Œº.cdf x ‚Üí Tendsto (fun n ‚Ü¶ (Œºs n).cdf x) atTop (ùìù (Œº.cdf x))) :
    Tendsto Œºs atTop (ùìù Œº) := by
  -- Use portmanteau theorem: show ‚à´f dŒºn ‚Üí ‚à´f dŒº for all bounded continuous f
  rw [ProbabilityMeasure.tendsto_iff_forall_integral_tendsto]

  intros f

  -- Let D be the set of continuity points of Œº.cdf
  let D := {x : ‚Ñù | ContinuousAt Œº.cdf x}

  have D_dense : Dense D := by
    -- D = {x : ‚Ñù | ContinuousAt Œº.cdf x} is the complement of discontinuity points
    let S := {x : ‚Ñù | ¬¨ContinuousAt Œº.cdf x}

    -- S is countable by the given theorem
    have S_countable : S.Countable := Monotone.countable_not_continuousAt Œº.cdf.mono'

    -- D = S·∂ú, so we need to show S·∂ú is dense
    have D_eq : D = S·∂ú := by
      ext x
      simp [D, S]

    rw [D_eq]
    exact Set.Countable.dense_compl ‚Ñù S_countable

  -- Convert tendsto to epsilon-delta form
  rw [Metric.tendsto_atTop]
  -- Now introduce epsilon and its positivity
  intros Œµ Œµ_pos

  -- Choose points a,b ‚àà D with specific properties using Lemma 4.3
  obtain ‚ü®a, b, a_lt_b, Fa_small, Fb_large, ha_cont, hb_cont‚ü© :=
    Œº.cdf.forall_pos_exists_lt_gt_continuousAt Œµ_pos

  have ha_in_D : a ‚àà D := ha_cont
  have hb_in_D : b ‚àà D := hb_cont

  -- Use convergence at continuity points a and b
  have h_conv_a : Tendsto (fun n => (Œºs n).cdf.toStieltjesFunction a) atTop (ùìù (Œº.cdf.toStieltjesFunction a)) :=
    h a ha_cont
  have h_conv_b : Tendsto (fun n => (Œºs n).cdf.toStieltjesFunction b) atTop (ùìù (Œº.cdf.toStieltjesFunction b)) :=
    h b hb_cont

  -- First show that F(b) - F(a) > 1 - 2Œµ
  have target_ineq : Œº.cdf.toStieltjesFunction b - Œº.cdf.toStieltjesFunction a > 1 - 2*Œµ := by
    linarith [Fa_small, Fb_large]

  -- The difference F_n(b) - F_n(a) converges to F(b) - F(a)
  have h_conv_diff : Tendsto (fun n => (Œºs n).cdf.toStieltjesFunction b - (Œºs n).cdf.toStieltjesFunction a) atTop
      (ùìù (Œº.cdf.toStieltjesFunction b - Œº.cdf.toStieltjesFunction a)) :=
    Tendsto.sub h_conv_b h_conv_a

  -- Since the limit is > 1 - 2Œµ, eventually the sequence is > 1 - 2Œµ
  -- Choose Œ¥ as half the gap above 1 - 2Œµ
  let Œ¥ := (Œº.cdf.toStieltjesFunction b - Œº.cdf.toStieltjesFunction a - (1 - 2*Œµ)) / 2
  have Œ¥_pos : Œ¥ > 0 := by
    simp only [Œ¥]
    linarith [target_ineq]

  -- Get N‚ÇÅ from convergence
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := Metric.tendsto_atTop.mp h_conv_diff Œ¥ Œ¥_pos

  have cdf_bound : ‚àÄ n ‚â• N‚ÇÅ, (Œºs n).cdf.toStieltjesFunction b - (Œºs n).cdf.toStieltjesFunction a > 1 - 2*Œµ := by
    intro n hn
    by_contra h_not
    push_neg at h_not
    -- So we have F_n(b) - F_n(a) ‚â§ 1 - 2Œµ

    -- From convergence, we know the difference is close
    have close := hN‚ÇÅ n hn
    rw [dist_eq_norm] at close

    -- This gives us |F_n(b) - F_n(a) - (F(b) - F(a))| < Œ¥
    -- which means F_n(b) - F_n(a) - (F(b) - F(a)) > -Œ¥
    have lower_bound : (Œºs n).cdf.toStieltjesFunction b - (Œºs n).cdf.toStieltjesFunction a -
                      (Œº.cdf.toStieltjesFunction b - Œº.cdf.toStieltjesFunction a) > -Œ¥ := by linarith [abs_lt.mp close]

    -- But from our assumption h_not and target_ineq:
    -- F_n(b) - F_n(a) ‚â§ 1 - 2Œµ and F(b) - F(a) > 1 - 2Œµ
    -- So F_n(b) - F_n(a) - (F(b) - F(a)) < (1 - 2Œµ) - (1 - 2Œµ + 2Œ¥) = -2Œ¥
    have upper_bound : (Œºs n).cdf.toStieltjesFunction b - (Œºs n).cdf.toStieltjesFunction a -
                      (Œº.cdf.toStieltjesFunction b - Œº.cdf.toStieltjesFunction a) ‚â§ -2*Œ¥ := by
      simp only [Œ¥] at target_ineq ‚ä¢
      linarith [h_not, target_ineq]
    linarith


  -- Use Lemma 4.5 to subdivide [a,b] with points from D
  obtain ‚ü®k, cs, cs_0, cs_last, cs_mono, cs_in_D, cs_approx‚ü© :=
    forall_exists_subdivision_dist_apply_lt_of_dense_of_continuous D_dense f.continuous
    ha_in_D hb_in_D a_lt_b Œµ_pos

  -- Define simple function h
  let h : ‚Ñù ‚Üí ‚Ñù := fun x => ‚àë j : Fin k, f (cs j.succ) * (Set.indicator (Ioc (cs ‚Üë‚Üëj) (cs j.succ)) 1 x)
  -- let h : ‚Ñù ‚Üí ‚Ñù := fun x => ‚àë j : Fin k, f (cs j.succ) * if x ‚àà Ioc (cs ‚Üë‚Üëj) (cs j.succ) then 1 else 0
  -- let h : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ ‚àë j : Fin k, f (cs j.succ) * (indicator (Ioc (cs j) (cs j.succ)) 1 x)

  -- Show |f(x) - h(x)| < Œµ for x ‚àà (a,b]
  have f_h_close : ‚àÄ x ‚àà Ioc a b, |f x - h x| < Œµ := by
    intros x hx

    -- Every x ‚àà (a,b] is covered by some interval (cs_j, cs_{j+1}]
    obtain ‚ü®j, hj‚ü© : ‚àÉ j : Fin k, x ‚àà Ioc (cs j) (cs j.succ) := by

      -- Define S as subset of Fin (k + 1)
      let S : Set (Fin (k + 1)) := {j | cs j < x}

      -- S is nonempty since cs 0 = a < x
      have S_nonempty : S.Nonempty := by
        use 0
        simp [S, cs_0]
        rw [Set.mem_Ioc] at hx
        linarith

      -- Convert to finset nonemptiness
      have S_toFinset_nonempty : S.toFinset.Nonempty := Set.toFinset_nonempty.mpr S_nonempty

      -- Get the maximum element
      let j_max := S.toFinset.max' S_toFinset_nonempty

      -- Show j_max ‚â† Fin.last k
      have h_not_last : j_max ‚â† Fin.last k := by
        intro h_eq
        have j_max_in_S : j_max ‚àà S := by
          rw [‚Üê Set.mem_toFinset]
          exact S.toFinset.max'_mem S_toFinset_nonempty
        have : cs (Fin.last k) < x := by
          rw [‚Üê h_eq]
          exact j_max_in_S  -- Now j_max_in_S : j_max ‚àà S means cs j_max < x

        rw [cs_last] at this
        rw [Set.mem_Ioc] at hx
        linarith

      -- Convert to Fin k using the new theorem
      have h_lt : j_max < Fin.last k := Fin.lt_last_iff_ne_last.mpr h_not_last
      have h_val_lt : j_max.val < k := h_lt

      let j : Fin k := ‚ü®j_max.val, h_val_lt‚ü©

      use j
      constructor
      ¬∑ -- cs ‚Üë‚Üëj < x
        have j_max_in_S : j_max ‚àà S := by
          rw [‚Üê Set.mem_toFinset]
          exact S.toFinset.max'_mem S_toFinset_nonempty
        simp [S] at j_max_in_S  -- This gives us cs j_max < x
        convert j_max_in_S
        simp [j]

      ¬∑ -- x ‚â§ cs j.succ
        by_contra h_not
        push_neg at h_not
        have succ_in_S : j.succ ‚àà S := by
          simp [S]
          exact h_not
        have succ_le_max : j.succ ‚â§ j_max := by
          apply S.toFinset.le_max'
          rwa [Set.mem_toFinset]
        have max_lt_succ : j_max < j.succ := by
          rw [Fin.lt_iff_val_lt_val]
          simp [j]
        omega

    -- Simplify h x to f (cs j.succ)
    have h_eq : h x = f (cs j.succ) := by
      simp only [h]
      -- The sum reduces to just the j-th term since intervals are disjoint
      rw [Finset.sum_eq_single j]
      ¬∑ -- The j-th term equals f (cs j.succ)
        change f (cs j.succ) * ((Ioc (cs ‚Üë‚Üëj) (cs j.succ)).indicator 1) x = f (cs j.succ)
        rw [Set.indicator_of_mem hj]
        simp
      ¬∑ -- All other terms are zero

        intro b _ hne
        -- Show x ‚àâ Ioc (cs ‚Üë‚Üëb) (cs b.succ) when b ‚â† j
        have x_not_in_b : x ‚àâ Ioc (cs ‚Üë‚Üëb) (cs b.succ) := by
          intro h_in_b
          -- Use trichotomy: either b < j or j < b
          cases' lt_or_gt_of_ne hne with h_lt h_gt
          ¬∑ -- Case: b < j
            have b_succ_le_j_cast : b.succ ‚â§ j.castSucc := by
              rw [Fin.succ_le_castSucc_iff]
              exact h_lt

            have cs_ineq : cs b.succ ‚â§ cs ‚Üë‚Üëj := by
              simp
              apply cs_mono b_succ_le_j_cast
            have x_gt_cs_j : cs ‚Üë‚Üëj < x := hj.1
            have x_le_cs_b : x ‚â§ cs b.succ := h_in_b.2
            linarith [cs_ineq, x_gt_cs_j, x_le_cs_b]
          ¬∑ -- Case: j < b
            have j_succ_le_b_cast : j.succ ‚â§ b.castSucc := by
              rw [Fin.succ_le_castSucc_iff]
              exact h_gt
            have cs_ineq : cs j.succ ‚â§ cs ‚Üë‚Üëb := by
              simp
              apply cs_mono j_succ_le_b_cast
            have x_le_cs_j : x ‚â§ cs j.succ := hj.2
            have x_gt_cs_b : cs ‚Üë‚Üëb < x := h_in_b.1
            linarith [cs_ineq, x_le_cs_j, x_gt_cs_b]

        -- Use indicator_of_not_mem and mul_zero
        rw [Set.indicator_of_not_mem x_not_in_b, mul_zero]
      ¬∑ -- j is in the range
        simp

    -- Now use cs_approx to bound |f x - f (cs j.succ)|
    rw [h_eq]
    have x_in_Icc : x ‚àà Icc (cs ‚Üë‚Üëj) (cs j.succ) := by
      exact Ioc_subset_Icc_self hj

    have cs_succ_in_Icc : cs j.succ ‚àà Icc (cs ‚Üë‚Üëj) (cs j.succ) := by
      constructor
      ¬∑ simp
        apply cs_mono (Fin.castSucc_le_succ j)
      ¬∑ rfl

    have := cs_approx j x x_in_Icc (cs j.succ) cs_succ_in_Icc
    exact this

  -- Get boundedness constant for f
  obtain ‚ü®C, hC‚ü© := BoundedContinuousFunction.bounded f
  -- Fix a point (say 0) to get a bound on the norm
  let K := ‚Äñf 0‚Äñ + C
  have norm_bound : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ K := by
    unfold K
    intro x
    have : dist (f x) (f 0) ‚â§ C := hC x 0
    rw [dist_eq_norm] at this

    have ineq : ‚Äñf x‚Äñ  ‚â§  ‚Äñ f 0‚Äñ + ‚Äñ f x - f 0‚Äñ := by
      exact norm_le_norm_add_norm_sub' (f x) (f 0)
    linarith

  clear hN‚ÇÅ h_conv_diff Fa_small Fb_large

  use N‚ÇÅ
  intro n hn

  -- First, use the triangle inequality: |‚à´ f dŒº‚Çô - ‚à´ h dŒº‚Çô| = |‚à´ (f - h) dŒº‚Çô| ‚â§ ‚à´ |f - h| dŒº‚Çô
  have triangle_ineq : |‚à´ (œâ : ‚Ñù), f œâ ‚àÇ‚Üë(Œºs n) - ‚à´ (œâ : ‚Ñù), h œâ ‚àÇ‚Üë(Œºs n)| ‚â§
    ‚à´ (œâ : ‚Ñù), |f œâ - h œâ| ‚àÇ‚Üë(Œºs n) := by
    rw [‚Üê integral_sub]
    apply MeasureTheory.abs_integral_le_integral_abs
    ¬∑ haveI : IsFiniteMeasure (Œºs n).toMeasure := MeasureTheory.IsZeroOrProbabilityMeasure.toIsFiniteMeasure (Œºs n).toMeasure
      exact BoundedContinuousFunction.integrable (Œºs n).toMeasure f
    ¬∑ -- Goal 2: ‚ä¢ Integrable h ‚Üë(Œºs n)
      -- First rewrite h to make the finset explicit
      unfold h
      apply MeasureTheory.integrable_finset_sum'
      intro j _
      -- Need to show each term f(cs j.succ) * indicator is integrable
      apply Integrable.const_mul
      apply integrable_indicator_const
      exact measurableSet_Ioc
    ¬∑ apply integrable_finsum_of_finite
      intro j
      apply integrable_indicator_const
      exact measurableSet_Ioc
    ¬∑ exact BoundedContinuousFunction.integrable f

    exact intervalIntegral.abs_integral_le_integral_abs _ _

  -- Now split the integral over (a,b] and its complement
  have integral_split : ‚à´ (œâ : ‚Ñù), |f œâ - h œâ| ‚àÇ‚Üë(Œºs n) =
    ‚à´ (œâ : ‚Ñù) in (Set.Ioc a b), |f œâ - h œâ| ‚àÇ‚Üë(Œºs n) +
    ‚à´ (œâ : ‚Ñù) in (Set.Ioc a b)·∂ú, |f œâ - h œâ| ‚àÇ‚Üë(Œºs n) := by
    rw [‚Üê integral_add_compl (measurableSet_Ioc) (integrable_abs_sub _ _)]
    -- where integrable_abs_sub comes from f and h being integrable

  -- Since h vanishes outside (a,b], we have f - h = f on (a,b]·∂ú
  have h_vanishes : ‚àÄ x ‚àâ Set.Ioc a b, h x = 0 := by
    intro x hx
    -- This follows from the definition of h as a sum over indicators
    simp [h]
    sorry

  -- Therefore |f - h| = |f| on (a,b]·∂ú
  have eq_on_compl : ‚à´ (œâ : ‚Ñù) in (Set.Ioc a b)·∂ú, |f œâ - h œâ| ‚àÇ‚Üë(Œºs n) =
    ‚à´ (œâ : ‚Ñù) in (Set.Ioc a b)·∂ú, |f œâ| ‚àÇ‚Üë(Œºs n) := by
    apply integral_congr_ae
    filter_upwards [ae_of_all _ h_vanishes] with x hx
    simp [hx, sub_zero]

  -- Combine everything
  rw [integral_split, eq_on_compl] at triangle_ineq








  -- Apply triangle inequality using the blueprint strategy
  have key_ineq : dist (‚à´ œâ, f œâ ‚àÇ(Œºs n : Measure ‚Ñù)) (‚à´ œâ, f œâ ‚àÇ(Œº : Measure ‚Ñù)) ‚â§
    ‚à´ œâ in Ioc a b, |f œâ - h œâ| ‚àÇ(Œºs n : Measure ‚Ñù) +
    ‚à´ œâ in (Ioc a b)·∂ú, ‚Äñf œâ‚Äñ ‚àÇ(Œºs n : Measure ‚Ñù) := by
    rw [dist_eq_norm, ‚Üê integral_sub]
    ¬∑ apply norm_integral_le_of_le_forall
      intro œâ
      by_cases h_mem : œâ ‚àà Ioc a b
      ¬∑ -- Inside [a,b]: use f_h_close
        simp [Set.indicator_of_mem h_mem, Set.indicator_of_not_mem (Set.not_mem_compl_iff.mpr h_mem)]
        rw [add_zero]
        exact le_abs_self _
      ¬∑ -- Outside [a,b]: h vanishes, so |f - h| = |f - 0| = |f|
        simp [Set.indicator_of_not_mem h_mem, Set.indicator_of_mem (Set.mem_compl h_mem)]
        rw [zero_add, sub_zero]
        rfl
    ¬∑ exact BoundedContinuousFunction.integrable f
    ¬∑ exact BoundedContinuousFunction.integrable f

  -- Bound the first integral by Œµ
  have bound‚ÇÅ : ‚à´ œâ in Ioc a b, |f œâ - h œâ| ‚àÇ(Œºs n : Measure ‚Ñù) ‚â§ Œµ / 2 := by
    apply integral_le_of_forall_le
    ¬∑ exact ae_of_all _ (fun œâ => abs_nonneg _)
    ¬∑ intro œâ h_mem
      exact le_of_lt (f_h_close œâ h_mem)

  -- Bound the second integral using CDF bounds
  have bound‚ÇÇ : ‚à´ œâ in (Ioc a b)·∂ú, ‚Äñf œâ‚Äñ ‚àÇ(Œºs n : Measure ‚Ñù) ‚â§ Œµ / 2 := by
    have decomp : (Ioc a b)·∂ú = Set.Iic a ‚à™ Set.Ioi b := by
      ext œâ
      simp [Set.Ioc, Set.compl_def]
      tauto
    rw [decomp, Set.integral_union]
    ¬∑ have bound_left : ‚à´ œâ in Set.Iic a, ‚Äñf œâ‚Äñ ‚àÇ(Œºs n : Measure ‚Ñù) ‚â§
          K * (Œºs n : Measure ‚Ñù) (Set.Iic a) := by
        apply integral_le_measure_mul_sup_norm
        exact hK_bound
      have bound_right : ‚à´ œâ in Set.Ioi b, ‚Äñf œâ‚Äñ ‚àÇ(Œºs n : Measure ‚Ñù) ‚â§
          K * (Œºs n : Measure ‚Ñù) (Set.Ioi b) := by
        apply integral_le_measure_mul_sup_norm
        exact hK_bound
      -- Use CDF bounds and the choice of N‚ÇÅ
      sorry -- Complete using Fa_small, Fb_large, and hN‚ÇÅ
    ¬∑ exact Set.disjoint_Iic_Ioi_of_lt a_lt_b

  -- Combine bounds
  linarith [key_ineq, bound‚ÇÅ, bound‚ÇÇ]





  -- Bound |‚à´f dŒº - ‚à´h dŒº| and |‚à´f dŒºn - ‚à´h dŒºn|
  have bound_Œº : |‚à´ x, f x ‚àÇŒº - ‚à´ x, h x ‚àÇŒº| ‚â§ (1 + 2 * ‚Äñf‚Äñ_‚àû) * Œµ := by
    sorry -- Use triangle inequality and boundedness

  have bound_Œºs : ‚àÄ n, |‚à´ x, f x ‚àÇ(Œºs n) - ‚à´ x, h x ‚àÇ(Œºs n)| ‚â§ (1 + 2 * ‚Äñf‚Äñ_‚àû) * Œµ := by
    sorry -- Similar bound for Œºs n

  -- Express ‚à´h dŒº and ‚à´h dŒºn using Lemma 4.6
  have h_integral_Œº : ‚à´ x, h x ‚àÇŒº = ‚àë j : Fin k, f (cs j.succ) * (Œº.cdf (cs j.succ) - Œº.cdf (cs j)) := by
    sorry -- Use Lemma 4.6

  have h_integral_Œºs : ‚àÄ n, ‚à´ x, h x ‚àÇ(Œºs n) =
    ‚àë j : Fin k, f (cs j.succ) * ((Œºs n).cdf (cs j.succ) - (Œºs n).cdf (cs j)) := by
    sorry -- Use Lemma 4.6

  -- Use convergence at continuity points
  have h_conv : Tendsto (fun n ‚Ü¶ ‚à´ x, h x ‚àÇ(Œºs n)) atTop (ùìù (‚à´ x, h x ‚àÇŒº)) := by
    rw [h_integral_Œº]
    simp_rw [h_integral_Œºs]
    -- Each term converges since cs j ‚àà D and cs j.succ ‚àà D
    apply tendsto_finset_sum
    intro j _
    apply Tendsto.const_mul
    apply Tendsto.sub
    ¬∑ exact h (cs j.succ) (cs_in_D j.succ)
    ¬∑ exact h (cs j) (cs_in_D j)

  -- Combine all bounds
  rw [tendsto_atTop_nhds]
  intros Œ¥ Œ¥_pos

  -- Choose N large enough for h convergence
  obtain ‚ü®N‚ÇÅ, hN‚ÇÅ‚ü© := eventually_atTop.mp (tendsto_atTop_nhds.mp h_conv Œ¥ Œ¥_pos)

  use N‚ÇÅ
  intros n hn

  -- Triangle inequality
  calc |‚à´ x, f x ‚àÇ(Œºs n) - ‚à´ x, f x ‚àÇŒº|
    ‚â§ |‚à´ x, f x ‚àÇ(Œºs n) - ‚à´ x, h x ‚àÇ(Œºs n)| +
      |‚à´ x, h x ‚àÇ(Œºs n) - ‚à´ x, h x ‚àÇŒº| +
      |‚à´ x, h x ‚àÇŒº - ‚à´ x, f x ‚àÇŒº| := by
        sorry -- Triangle inequality
    _ ‚â§ (1 + 2 * ‚Äñf‚Äñ_‚àû) * Œµ + Œ¥ + (1 + 2 * ‚Äñf‚Äñ_‚àû) * Œµ := by
        sorry -- Apply bounds
    _ < Œ¥ + 2 * (1 + 2 * ‚Äñf‚Äñ_‚àû) * Œµ := by
        sorry -- Arithmetic

end weak_convergence_cdf


section levy_prokhorov_metric

open MeasureTheory Filter Topology

variable (F G :CumulativeDistributionFunction)

namespace CumulativeDistributionFunction

lemma tendsto_probabilityMeasure_iff_forall_continuousAt_tendsto
    (Fs : ‚Ñï ‚Üí CumulativeDistributionFunction) (G : CumulativeDistributionFunction) :
    Tendsto (fun i ‚Ü¶ (Fs i).probabilityMeasure) atTop (ùìù G.probabilityMeasure)
      ‚Üî ‚àÄ x, ContinuousAt G x ‚Üí Tendsto (fun i ‚Ü¶ Fs i x) atTop (ùìù (G x)) := by
  constructor
  ¬∑ intro h x hGx
    have key := @tendsto_apply_of_tendsto_of_continuousAt ‚Ñï atTop
                (fun i ‚Ü¶ (Fs i).probabilityMeasure) G.probabilityMeasure h x
    simp_all
  ¬∑ intro h
    apply tendsto_of_forall_continuousAt_tendsto_cdf
    simpa using h

noncomputable def equiv_levyProkhorov :
    CumulativeDistributionFunction ‚âÉ LevyProkhorov (ProbabilityMeasure ‚Ñù) :=
  equiv_probabilityMeasure.trans (LevyProkhorov.equiv (ProbabilityMeasure ‚Ñù)).symm

noncomputable instance : MetricSpace CumulativeDistributionFunction := by
  apply MetricSpace.induced equiv_levyProkhorov
  ¬∑ intro F G h
    simpa only [EmbeddingLike.apply_eq_iff_eq] using h
  ¬∑ exact levyProkhorovDist_metricSpace_probabilityMeasure

noncomputable def homeomorph_levyProkhorov :
    CumulativeDistributionFunction ‚âÉ‚Çú LevyProkhorov (ProbabilityMeasure ‚Ñù) :=
  Equiv.toHomeomorphOfIsInducing equiv_levyProkhorov ‚ü®rfl‚ü©

noncomputable def homeomorph_probabilityMeasure :
    CumulativeDistributionFunction ‚âÉ‚Çú ProbabilityMeasure ‚Ñù :=
  homeomorph_levyProkhorov.trans homeomorph_probabilityMeasure_levyProkhorov.symm

lemma homeomorph_probabilityMeasure_apply_eq (F : CumulativeDistributionFunction) :
    homeomorph_probabilityMeasure F = F.probabilityMeasure :=
  rfl

/-- The standard characterization of convergence of cumulative distribution functions. -/
lemma tendsto_iff_forall_continuousAt_tendsto
    (Fs : ‚Ñï ‚Üí CumulativeDistributionFunction) (G : CumulativeDistributionFunction) :
    Tendsto Fs atTop (ùìù G) ‚Üî
      ‚àÄ x, ContinuousAt G x ‚Üí Tendsto (fun i ‚Ü¶ Fs i x) atTop (ùìù (G x)) := by
  rw [‚Üê tendsto_probabilityMeasure_iff_forall_continuousAt_tendsto]
  constructor
  ¬∑ intro h
    simp_rw [‚Üê homeomorph_probabilityMeasure_apply_eq]
    apply homeomorph_probabilityMeasure.continuous.continuousAt.tendsto.comp h
  ¬∑ intro h
    convert homeomorph_probabilityMeasure.symm.continuous.continuousAt.tendsto.comp h
    ¬∑ ext1 i
      exact EquivLike.inv_apply_eq_iff_eq_apply.mp rfl
    ¬∑ exact EquivLike.inv_apply_eq_iff_eq_apply.mp rfl

end CumulativeDistributionFunction

end levy_prokhorov_metric



section continuous_mulAction

namespace CumulativeDistributionFunction

lemma continuous_mulAction :
    Continuous fun (‚ü®A, F‚ü© : AffineIncrEquiv √ó CumulativeDistributionFunction) ‚Ü¶ A ‚Ä¢ F := by
  rw [continuous_iff_seqContinuous]
  intro AFs BG h_lim
  rw [tendsto_iff_forall_continuousAt_tendsto]
  intro x hBGx
  simp only [Function.comp_apply, mulAction_apply_eq]
  sorry -- **Issue #54** (action-on-cdf-continuous)

end CumulativeDistributionFunction

end continuous_mulAction
